# 选择排序
思路：1.遍历一个数组找出最小的一个数放在位置0.
     2.遍历剩下的n-1个元素将最小的数放在位置2.
     3.遍历剩下的n-2个元素将最小的数放在位置3.
     4....
     5.在剩余的3个数中将最小的数放在位置n-3.
     6.在剩余的两个数中将最小的放在位置n-2.
     7.将最后一个数放在位置n-1.

数组步骤；1.从数组a的begin到end中选择最小的那个元素，返回其下标
     2.交换两个元素的位置。

# 插入排序
思路：1.0号元素不做任何操作。
     2.1号元素与0号元素比较如果大于0号则不做任何操作，如果小于1号则与0号交换位置。
     3.2号元素与1号元素比较，如果大于1号则不做任何操作，如果小于1号则交换与1号位置，在与0号比较，如果小于则交换与0号的位置，如果大于则不做任何操作。
     4.。。。
     插入排序的核心思路是将每个元素插入到数组中合适的位置中去。与选择排序不同，他不需要遍历整个数组，但我感觉他们的复杂度是相近的。

数组步骤：1.构建一个指定长度的数组。
        2.构造打印函数print_array和swap来交换数组中的元素值。  
        3.对每一个目标元素，若该元素比前一个元素小，则swap两元素。

链表步骤：1. 创建链表结构体。
        2.创建头节点head,为空节点，指向整个链表的第一个节点。
        3.创建一个函数add_at head在head节点之后插入节点，从而构建一个链表队列。
        4.创建一个函数find_position寻找指定节点在该链表中的正确排序位置。
        5.将目标节点转移到pos节点。
        6.创建inset_sort整合以上函数。
         
# 冒泡排序
思路：1.将数组中两两一组进行比较大的放后面，第一次冒泡排序后，最大的元素被放在最后端。
     2.继续进行两两比较将第二大的元素放到n-2的位置。
     3.直至所有元素排序完成。
     冒泡排序类似于吐泡泡，将最大的泡泡向外排，小的泡泡往里排。